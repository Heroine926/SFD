#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <iostream>
#include <dlfcn.h>
#include <vector>
#include <time.h>
#include <iosfwd>
#include <utility>


#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/opencv.hpp>


#include "/data/home/larainelu/SFD/SFD_project/soSFD.h"

using namespace std;
using namespace cv;

#define LIB_SFD "/data/home/larainelu/SFD/SFD_project/sfd_FaceDetect.so"



extern "C"
{
	typedef int (*F_sfd_face_detection)(const void *p_cvmat, void *p_vec_vec_rect, int batchSize);
	typedef int (*F_sfd_face_detection_init)(const string& model_def, const string& trained_file, int gpu_id);
}


void motion_blur(Mat &srcImage)
{
    int OffsetJ[4] = { 2, -2, -2, 2 };
    int OffsetI[4] = { -2, -2, 2, 2 };

    int sumB,sumG,sumR;
    for(int j = 0;j<srcImage.rows;j++)
    {
	for(int i = 0;i<srcImage.cols;i++)
	{
	    sumB = 0;sumG = 0;sumR = 0;
	    for(int k = 0;k<4;k++)
	    {
		int JJ = j + OffsetJ[k];
		int II = i + OffsetI[k];

		if(JJ < 0)
		{
		    JJ = 0;
		}
		else if(JJ >= srcImage.rows)
		{
		    JJ = srcImage.rows - 1;
		}
		if(II < 0)
		{
		    II = 0;
		}else if(II >= srcImage.cols)
		{
		    II = srcImage.cols - 1;
		}

		sumB += srcImage.at<Vec3b>(JJ,II)[0];
		sumG += srcImage.at<Vec3b>(JJ,II)[1];
		sumR += srcImage.at<Vec3b>(JJ,II)[2];
	    }

	    srcImage.at<Vec3b>(j,i)[2] = (sumR+2)>>2;
	    srcImage.at<Vec3b>(j,i)[1] = (sumG+2)>>2;
	    srcImage.at<Vec3b>(j,i)[0] = (sumB+2)>>2;
	}
    }
}




int main()//int argc, char**argv)
{
	string test_image_path = "/data/home/larainelu/DataSet/TAXI/all/";//  = argv[1];
	string image_list_file = "/data/home/larainelu/DataSet/TAXI/all/image_list.txt";//  = argv[2];
	string blur_img_path = "/data/home/larainelu/DataSet/TAXI_blur/Data_train/";
        
	int res = 0;

	ifstream img_list;
	img_list.open(image_list_file.data());

	if (!img_list)
	{
		std::cerr << image_list_file << " openÂ error." <<endl;;
		exit(1);
	}
	string img_name;
	
	bool end = false;
	int batchSize = 1 ;
	while(!end)
    	{


		
		{
		        if(!getline(img_list,img_name))
			{
			    end = true;
			    break;
			}
			
			string Img_path = test_image_path + img_name;
			string blur_imagePath = blur_img_path + img_name;
			cv::Mat img = cv::imread(Img_path,-1);
			if(img.empty())
			{
				cout<<"ERROR: "<<Img_path<<" is empty"<<endl;
				continue;
			}
			///////////motion blur////////////////////
			motion_blur(img);
			printf("%s\n",blur_imagePath.c_str());
			cv::imwrite(blur_imagePath,img);
		}
		
	}

	return 0;
}

